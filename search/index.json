[{"content":"Flask GUI The code is written in Python so I can utilize ROS in the future. I wanted to use a GUI that I can use in the web browser, so it will work on any platform including mobile. The RPI3 in my R2D2 will have an wifi connection. So I can connect Ad-Hoc directly to the RPI3 and use the browser to control some of the accessories in my R2D2. I still feel radio control is most important for the movements right now. Going to large events, I find Bluetooth, Zigbee and Wifi connections get a little flakey and I do not want my R2D2 to run away. But if the accessories do not function through user controls, it will be fine.\nI created a quick page just for the head right now. I used HTML image mapping to surround the arms as button clicks. The button clicks will then call the Flask API. The API will then determine which API call (link) and run the python function. I mainly work with classes in Python. So I created an Arm Object and the Flask API has access to the object so it can make the function calls.\nAll this code is available on my Github page. https://github.com/artoo-ai/R2D2/\nR2D2 Flask GUI Interface for Arms Video RPI3 Running the Servos using Flask GUI\nCode Flask API code and HTML page.\nFlask API https://github.com/artoo-ai/R2D2/blob/master/r2d2_main.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 #!/usr/bin/env python import time from frame.arms import Arms from flask import Flask, render_template, Response, request, redirect, url_for from threading import Thread import os class R2D2: def __init__(self): \u0026#34;\u0026#34;\u0026#34; Initialize the R2D2. \u0026#34;\u0026#34;\u0026#34; # Init the Arms self.arms = Arms(0, 1) # Init the web server for the GUI #self.web_thread = Thread(target=self.init_web_server) #self.web_thread.start() self.init_web_server() def shutdown(self): \u0026#34;\u0026#34;\u0026#34; Shutdown the R2D2 :return: \u0026#34;\u0026#34;\u0026#34; self.arms.shutdown() def init_web_server(self): template_dir =os.path.dirname(os.path.realpath(__file__)) template_dir = os.path.join(template_dir, \u0026#39;web\u0026#39;) print(template_dir) app = Flask(__name__, template_folder=template_dir, static_url_path=\u0026#39;/static\u0026#39;) @app.route(\u0026#34;/\u0026#34;) def index(): return render_template(\u0026#39;index.html\u0026#39;) #return \u0026#34;Hello World!\u0026#34; @app.route(\u0026#34;/test_arms/\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def test_arms(): self.test_arms() #return \u0026#34;Test Arms\u0026#34; return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#34;/open_top_arm/\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def open_top_arm(): self.arms.open_top_arm() time.sleep(0.5) self.arms.close_top_arm() return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#34;/open_bottom_arm/\u0026#34;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def open_bottom_arm(): self.arms.open_bottom_arm() time.sleep(0.5) self.arms.close_bottom_arm() return render_template(\u0026#39;index.html\u0026#39;) app.run(host=\u0026#39;0.0.0.0\u0026#39;) def test_arms(self): \u0026#34;\u0026#34;\u0026#34; Test the arms. :return: \u0026#34;\u0026#34;\u0026#34; self.arms.test_arms() if __name__ == \u0026#39;__main__\u0026#39;: r2d2 = R2D2() #r2d2.test_arms() #r2d2.shutdown() Webpage https://github.com/artoo-ai/R2D2/blob/master/web/index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;R2D2 Controls\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .button { display: inline-block; border-radius: 4px; border: none; position: relative; background-color: #4CAF50; border: none; font-size: 28px; color: #FFFFFF; padding: 20px; width: 200px; text-align: center; -webkit-transition-duration: 0.4s; /* Safari */ transition: all 0.5s; transition-duration: 0.4s; text-decoration: none; overflow: hidden; cursor: pointer; margin: 5px; } .button:after { content: \u0026#34;\u0026#34;; background: #f1f1f1; display: block; position: absolute; padding-top: 300%; padding-left: 350%; margin-left: -20px !important; margin-top: -120%; opacity: 0; transition: all 0.8s } .button:active:after { padding: 0; margin: 0; opacity: 1; transition: 0s } .button span { cursor: pointer; display: inline-block; position: relative; transition: 0.5s; } .button span:after { content: \u0026#39;\\00bb\u0026#39;; position: absolute; opacity: 0; top: 0; right: -20px; transition: 0.5s; } .button:hover span { padding-right: 25px; } .button:hover span:after { opacity: 1; right: 0; } * { box-sizing: border-box; } /* Create two unequal columns that floats next to each other */ .column { float: left; padding: 10px; height: 300px; /* Should be removed. Only for demonstration */ } .left { width: 25%; } .right { width: 75%; } /* Clear floats after the columns */ .row:after { content: \u0026#34;\u0026#34;; display: table; clear: both; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;row\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt; \u0026lt;form action=\u0026#34;/test_arms/\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; style=\u0026#34;vertical-align:middle\u0026#34; name=\u0026#34;testArmsBtn\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Test Arms\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form action=\u0026#34;/open_top_arm/\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; style=\u0026#34;vertical-align:middle\u0026#34; name=\u0026#34;openTopArmBtn\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Open Top Arm\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;form action=\u0026#34;/open_bottom_arm/\u0026#34; method=\u0026#34;get\u0026#34;\u0026gt; \u0026lt;button class=\u0026#34;button\u0026#34; style=\u0026#34;vertical-align:middle\u0026#34; name=\u0026#34;openBottomArmBtn\u0026#34; type=\u0026#34;submit\u0026#34;\u0026gt;\u0026lt;span\u0026gt;Open Bottom Arm\u0026lt;/span\u0026gt;\u0026lt;/button\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;column\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/static/r2d2.png\u0026#34; alt=\u0026#34;Workplace\u0026#34; usemap=\u0026#34;#workmap\u0026#34;\u0026gt; \u0026lt;map name=\u0026#34;workmap\u0026#34;\u0026gt; \u0026lt;area shape=\u0026#34;rect\u0026#34; coords=\u0026#34;34,44,270,350\u0026#34; alt=\u0026#34;TestArms\u0026#34; href=\u0026#34;/test_arms/\u0026#34;\u0026gt; \u0026lt;area shape=\u0026#34;rect\u0026#34; coords=\u0026#34;360,600,800,700\u0026#34; alt=\u0026#34;TopArm\u0026#34; href=\u0026#34;/open_top_arm/\u0026#34;\u0026gt; \u0026lt;area shape=\u0026#34;rect\u0026#34; coords=\u0026#34;350,720,820,800\u0026#34; alt=\u0026#34;BottomArm\u0026#34; href=\u0026#34;/open_bottom_arm/\u0026#34;\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","date":"2020-06-13T12:29:40+06:00","image":"https://www.artoo.ai/p/r2d2-flask-gui/r2d2_flask_sm_huecb0f4486cddbad7e8839b7ec4541d37_31325_120x120_fill_box_smart1_3.png","permalink":"https://www.artoo.ai/p/r2d2-flask-gui/","title":"R2D2 Flask GUI"},{"content":"Installation Install ROS and ROS2. Ensure both are installed on the machine.\nhttp://wiki.ros.org/melodic/Installation/Ubuntu\nhttps://github.com/ros2/ros1_bridge/blob/master/README.md#example-1a-ros-1-talker-and-ros-2-listener\nRun Bridge Source the ROS1 then the ROS2 workspaces. Make sure you do it in this order. At the very least, source the ROS workspace. Then set the master URI for ROS. Then start the bridge\n1 2 3 . /opt/ros/melodic/setup.bash export ROS_MASTER_URI=http://10.42.0.1:11311 ros2 run ros1_bridge dynamic_bridge View ROS Topics as a test 1 2 3 4 export ROS_MASTER_URI=http://10.42.0.1:11311 rostopic list rosnode list rosmsg list Get the ROS Topic Message Types 1 2 3 ros2 topic list rostopic list rostopic type /camera/person/detection_image | rosmsg show ","date":"2019-12-18T12:29:40+06:00","permalink":"https://www.artoo.ai/p/ros1-bridge/","title":"ROS1 Bridge"},{"content":"I had issues getting ROS2 on to RPi3. It all revolved around ArmV7 vs ARM64. All the linux distributions need to ARM64. It also has to be the latest version of Ubuntu. I tried many ways to get the latest version of Ubuntu (18.04), but then when using \u0026ldquo;apt\u0026rdquo; to install ROS2, or build ROS2 from source I always still got an error.\nI then saw that RPi3 not supports Ubuntu RPi3 Server edition. Since the ROS2 on the RPi3 I do not plan to use any of the visual tools, it seemed fine to use Ubuntu Server edition.\nDownload Latest Ubuntu Server http://cdimage.ubuntu.com/ubuntu/releases/bionic/release/ubuntu-18.04.2-preinstalled-server-arm64+raspi3.img.xz\nThere may be a newer version when you read this, so you can look here for the latest: http://cdimage.ubuntu.com/ubuntu/releases/bionic/release/\nYou are looking for: preinstalled-server-arm64+raspi3.img.xz\nDownload the latest version of Ubuntu 18.04\nCreate SD Memory Card with Ubuntu Untar the image on your system.\nThen burn the image to the SD card using Etcher https://www.balena.io/etcher/\nLoad the Ubuntu Install the SD Card into the RPi3\nBoot up the RPi3\nCreate a password for the ubuntu user.\nInstall RPI.GPIO The current version of RPI.GPIO does not work on this version of Ubuntu because Ubuntu Server 18.04 does not list the RPI version type correctly compared to Raspbain. So you need to use a patched version.\n1 2 3 4 sudo apt install adafruit-circuitpython-servokit sudo uninstall jetson.GPIO sudo apt install mercurial sudo pip3 install --upgrade hg+http://hg.code.sf.net/p/raspberry-gpio-python/code#egg=RPi.GPIO Setup Adafruit Packages 1 2 export BLINKA_FORCEBOARD=RASPBERRY_PI_3B export BLINKA_FORCECHIP=BCM2XXX To determine board and chip type review results of the following commands.\n1 cat /proc/device-tree/mode The list of board and chips options are in the following files:\n1 2 /home/ubuntu/.local/lib/python3.6/site-packages/adafruit_platformdetect/chip.py /home/ubuntu/.local/lib/python3.6/site-packages/adafruit_platformdetect/board.py Modify board.py\n1 2 3 4 5 6 7 @property def any_raspberry_pi(self): \u0026#34;\u0026#34;\u0026#34;Check whether the current board is any Raspberry Pi.\u0026#34;\u0026#34;\u0026#34; if os.environ[\u0026#39;BLINKA_FORCEBOARD\u0026#39;] == RASPBERRY_PI_3B: return True return self._pi_rev_code() is not None Add I2C Permissions 1 2 3 4 sudo groupadd i2c sudo chown :i2c /dev/i2c-1 sudo chmod g+rw /dev/i2c-1 sudo usermod -aG i2c ubuntu The default user name is \u0026ldquo;ubuntu\u0026rdquo;, so replace \u0026ldquo;ubuntu\u0026rdquo; in usermod command if are using a different user name.\nThen logout and login or restart your SSH to have changes take affect. When you log back in, you will need to export your options board configuration again.\nInstall ROS2 Follow all the instructions here to install ROS2. I did not run into any issues.\nhttps://index.ros.org/doc/ros2/Installation/Dashing/Linux-Install-Debians/\nTest ROS2 Installation Now to test the installation. Follow all these instructions here: https://index.ros.org/doc/ros2/Tutorials/Colcon-Tutorial/\n1 2 3 4 5 6 mkdir -p ~/ros2_example_ws/src cd ~/ros2_example_ws git clone https://github.com/ros2/examples src/examples cd ~/ros2_example_ws/src/examples/ git checkout $ROS_DISTRO cd ~/ros2_example_ws Build the Publisher and Subcriber examples.\nYou can use the tab to autocomplete the ros2 commands.\nPublisher 1 2 3 4 cd ~/ros2_example_ws/src/examples/rclpy/topics/minimal_publisher/ colcon build --symlink-install . install/setup.bash ros2 run examples_rclcpp_minimal_publisher publisher_member_function You should see an output\n1 2 3 4 5 6 7 8 9 10 [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 17\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 18\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 19\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 20\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 21\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 22\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 23\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 24\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 25\u0026#34; [INFO] [minimal_publisher]: Publishing: \u0026#34;Hello World: 26\u0026#34; You will need to create an SSH connection to have a new terminal window open to start another process. Note the IP address of the RPi3 board when you logged in. Or you can use the \u0026ldquo;\u0026amp;\u0026rdquo; at the end of the ROS2 command to start the command in the background. You will then need to use \u0026ldquo;ps -aux\u0026rdquo; and \u0026ldquo;kill\u0026rdquo; to stop the process later.\nSubscriber 1 2 3 4 cd ~/ros2_example_ws/src/examples/rclpy/topics/minimal_subscriber/ colcon build --symlink-install . install/setup.bash ros2 run examples_rclcpp_minimal_subscriber subscriber_member_function You should see an output\nIf you see the 2 talking to each other, then everything is working\n","date":"2019-08-22T12:29:40+06:00","permalink":"https://www.artoo.ai/p/install-ros2-on-raspberry-pi-3-rpi3/","title":"Install ROS2 On Raspberry Pi 3 (RPi3)"},{"content":"RPI3 You can use the RPI3 to use the servos. But the servo power will need to separte from the RPI3. The RPI3\u0026rsquo;s 5V is not enough to use servos long term. For initial testing they will work. But what you will find is the servos will glitch if connected to the RPI3\u0026rsquo;s header. The RPI3 causes the glitches. So eventually you need to find an alternative way to run the servos. There are two options I had on hand: a Maestro Mirco and PCA9685.\nPCA9685 The PCA9685 requires 2 power inputs: 3.3V and 5V. The 3.3V is for the PCA9685 board. The 5V is for the Servo Power. You will use the RPI3\u0026rsquo;s 3.3V to power the PCA9685 board. But you will need to use an alternative 5V supply to power the servos. The RPI3\u0026rsquo;s 5V is not enough to power the servos. It may work a little, but it cannot be used long term. The USB cell phone battery charges can be used as the 5V supply.\nThis board can handle up to 16 servos or motor controllers. On my DonkeyCar I control the steering and motors using this board and it has been very responsive. This should fit all my needs for servo controls. In my dome I will have a lot of servos to control, up to 10 I believe. I may have a separte one of these boards just for the dome. These boards can also be daisy chained. You just need to change the address by soldering 2 pads together.\nNext step, create a Node and Topic and wires this all up to the Flask API.\nSchematic 1 2 3 4 5 6 RPI3 PCA9685 ------------------------------ Pin 1 (3.3V) VCC Pin 3 (GPIO2) SDA Pin 5 (GPIO3) SCL Pin 9 (GND) GND Servo Color Code 1 2 3 Brown = GND Red = Power Orange = Signal 1 2 3 4 Power Supply PCA9685 ------------------------------ 5V 5V GND GND RPI3 Servo PCA9685 R2D2 Arms RPI3 and PCA9685 Running the Servos Code Packages to install on Ubuntu 1 2 sudo apt install python-smbus sudo apt install i2c-tools Packages to install in Python 1 pip install adafruit-circuitpython-servokit Source Code Used https://github.com/ricoai/R2D2/blob/master/controls/adafruit_servo_driver.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 from adafruit_servokit import ServoKit import time class AdafruitServoControl: \u0026#34;\u0026#34;\u0026#34; Use the Adafruit PCA9685 board to control the servos. https://learn.adafruit.com/adafruit-16-channel-servo-driver-with-raspberry-pi?view=all pip install adafruit-circuitpython-servokit sudo apt-get install python-smbus sudo apt-get install i2c-tools \u0026#34;\u0026#34;\u0026#34; def __init__(self, min_servo=750, max_servo=2500): \u0026#34;\u0026#34;\u0026#34; Initialize the maestro. Set the comm port if you need to set the specific. Set the min and max servo pulse width if not default. :param comm_port: Comm port of the maestro. :param min_servo: Min servo pulse width in quarter seconds. :param max_servo: Max servo pulse width in quarter seconds. \u0026#34;\u0026#34;\u0026#34; self.kit = None # Hold the Adafruit Servokit self.min_servo = min_servo # Min pulse width of servo in quarter seconds self.max_servo = max_servo # Max pulse width of servo in quarter seconds self.setup_controller() # Setup maestro def setup_controller(self): \u0026#34;\u0026#34;\u0026#34; Setup the maestro controller :return: \u0026#34;\u0026#34;\u0026#34; self.kit = ServoKit(channels=16) self.kit.servo[0].set_pulse_width_range(self.min_servo, self.max_servo) self.kit.servo[1].set_pulse_width_range(self.min_servo, self.max_servo) self.kit.servo[0].angle = 0 self.kit.servo[1].angle = 0 def center(self): \u0026#34;\u0026#34;\u0026#34; Center the servo. :return: \u0026#34;\u0026#34;\u0026#34; self.set_angle(0.0) # CENTER (6000) def set_angle(self, chan, angle): \u0026#34;\u0026#34;\u0026#34; Set the servo to the given angle. :param chan: Servo channel to move :param angle: Angle to move the servo :return: \u0026#34;\u0026#34;\u0026#34; if angle \u0026gt; 180: angle = 180 if angle \u0026lt; 0: angle = 0 self.kit.servo[chan].angle = angle print(\u0026#34;Chan: \u0026#34; + str(chan) + \u0026#34; angle: \u0026#34; + str(self.kit.servo[chan].angle)) if __name__ == \u0026#39;__main__\u0026#39;: servo = AdafruitServoControl() time.sleep(1.0) servo.set_angle(0, 180) servo.set_angle(1, 180) time.sleep(1.5) servo.set_angle(0, 0) servo.set_angle(1, 0) Parts List The R2D2 arm holder can be found at http://astromech.com/\n","date":"2019-06-15T12:29:40+06:00","image":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3-with-pca9685/sch_pca9685_sm_hucd00f0ebc6ede0518264e50e9f01b961_20281_120x120_fill_box_smart1_3.png","permalink":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3-with-pca9685/","title":"R2D2 Arm Connected to RPI3 With PCA9685"},{"content":"RPI3 You can use the RPI3 to use the servos. But the servo power will need to separte from the RPI3. The RPI3\u0026rsquo;s 5V is not enough to use servos long term. For initial testing they will work. But what you will find is the servos will glitch if connected to the RPI3\u0026rsquo;s header. The RPI3 causes the glitches. So eventually you need to find an alternative way to run the servos. There are two options I had on hand: a Maestro Mirco and PCA9685.\nMaestro Micro The Maestro Micro can be used, but it will require a 3.3V to 5V TTL level convert for the serial communication. The Maestro Micro uses 5V TTL logic. The RPI3 uses 3.3V TTL logic. So for the 2 boards to communicate through serial communication, you will need a TTL level converter. I ended up not using this board, because the RPI3 needs power, the Maestro Micro needs power and the TTL Level Convert needs power. This required too many connections versus the PCA9685. And the PCA9685 has 16 channels and I haved used it before in my DonkeyCar.\nI do not plan to persue this board any more. I will stick with the PCA9685 that you can see in my next blog post.\nSchematic Image From: https://rimstar.org/science_electronics_projects/servo_motor_with_raspberry_pi_and_pololu_maestro.htm Image From: https://rimstar.org/science_electronics_projects/servo_motor_with_raspberry_pi_and_pololu_maestro.htm\nRPI3 and PCA9685 Running the Servos RPI3 Running the Servos Code Maestro Library You will need to download the Maestro library. You can find it on my github for now. You will also need to configure the RPI3 to handle using the serial port. The source code gives the instructions in the comments at the top.\nhttps://github.com/artoo-ai/R2D2/blob/master/controls/maestro.py\nSource Code Used https://github.com/artoo-ai/R2D2/blob/master/controls/maestro_servo_control.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 import maestro import time import sys class MaestroServoControl: \u0026#34;\u0026#34;\u0026#34; Use the Maestro board to control the servos. 1. Disable console serial sudo raspi-config select interfacing options -\u0026gt; Serial -\u0026gt; No -\u0026gt; Yes save \u0026amp; exit 2. Install pyserial python -m pip install pyserial (may be a bit slow) 3. Clone Repo git clone https://github.com/FRC4564/Maestro 4. Disable bluetooth uart sudo nano /boot/config.txt append to bottom: dtoverlay=pi3-disable-bt save \u0026#34;\u0026#34;\u0026#34; def __init__(self, comm_port=\u0026#39;/dev/ttyACM0\u0026#39;, min_servo=3000.0, max_servo=9000.0): \u0026#34;\u0026#34;\u0026#34; Initialize the maestro. Set the comm port if you need to set the specific. Set the min and max servo pulse width if not default. :param comm_port: Comm port of the maestro. :param min_servo: Min servo pulse width in quarter seconds. :param max_servo: Max servo pulse width in quarter seconds. \u0026#34;\u0026#34;\u0026#34; self.comm_port = comm_port # Serial comm port self.maestro = None # Hold the maestro controller self.min_servo = min_servo # Min pulse width of servo in quarter seconds self.max_servo = max_servo # Max pulse width of servo in quarter seconds self.setup_controller() # Setup maestro def setup_controller(self): \u0026#34;\u0026#34;\u0026#34; Setup the maestro controller :return: \u0026#34;\u0026#34;\u0026#34; self.maestro = maestro.Controller(self.comm_port) self.maestro.setRange(0, self.min_servo, self.max_servo) print(\u0026#34;Min Servo: \u0026#34; + str(self.maestro.getMin(0))) print(\u0026#34;Max Servo: \u0026#34; + str(self.maestro.getMax(0))) def shutdown(self): \u0026#34;\u0026#34;\u0026#34; Shutdown the object. This will properly shutdown everything. :return: \u0026#34;\u0026#34;\u0026#34; self.maestro.close() def center(self): \u0026#34;\u0026#34;\u0026#34; Center the servo. :return: \u0026#34;\u0026#34;\u0026#34; self.set_angle(0.0) # CENTER (6000) def set_angle(self, chan, angle): \u0026#34;\u0026#34;\u0026#34; Set the servo to the given angle. :param chan: Servo channel to move :param angle: Angle to move the servo :return: \u0026#34;\u0026#34;\u0026#34; if angle \u0026gt; 180: angle = 180 if angle \u0026lt; 0: angle = 0 curr_pos = self.maestro.getPosition(chan) print(\u0026#34;Current Servo Position: \u0026#34; + str(chan) + \u0026#34; pw: \u0026#34; + str(curr_pos)) pw = self.calc_quater_sec_pulse_width(angle) print(\u0026#34;Servo: \u0026#34; + str(chan) + \u0026#34; angle: \u0026#34; + str(angle) + \u0026#34; pw: \u0026#34; + str(pw)) self.maestro.setTarget(chan, int(pw)) new_pos = self.maestro.getPosition(chan) print(\u0026#34;New Servo Position: \u0026#34; + str(chan) + \u0026#34; pw: \u0026#34; + str(new_pos)) def calc_quater_sec_pulse_width(self, angle): \u0026#34;\u0026#34;\u0026#34; Calculate the pulse width in quarter seconds based off the angle given. :param angle: :return: Duty cycle for servo based off angle. \u0026#34;\u0026#34;\u0026#34; if angle \u0026lt;= 0.0: return self.min_servo if angle \u0026gt;= 180.0: return self.max_servo return (self.max_servo + self.min_servo) / 180.0 * angle def set_speed(self, chan, speed): self.maestro.setSpeed(chan, speed) def set_accel(self, chan, speed): self.maestro.setAccel(chan, speed) if __name__ == \u0026#39;__main__\u0026#39;: #servos = MaestroServoControl(comm_port=\u0026#34;/dev/ttyAMA0\u0026#34;) #servos.set_speed(0, 10) #servos.set_speed(1, 10) #servos.set_angle(0, 90.0) #servos.set_angle(1, 90.0) #servos.shutdown() import maestro servo = maestro.Controller() servo.setAccel(0, 4) # set servo 0 acceleration to 4 servo.setTarget(0, 6000) # set servo to move to center position servo.setSpeed(1, 10) # set speed of servo 1 x = servo.getPosition(1) # get the current position of servo 1 servo.close() Parts List The R2D2 arm holder can be found at http://astromech.com/\n","date":"2019-06-14T12:29:40+06:00","image":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3-with-micro-maestro/sch_maestro_sm_hu0979340a50fc69ccc1de0cfc1e1b05fc_45893_120x120_fill_box_smart1_3.png","permalink":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3-with-micro-maestro/","title":"R2D2 Arm Connected to RPI3 With Micro Maestro"},{"content":"RPI3 You can use the RPI3 to use the servos. But the servo power will need to separte from the RPI3. The RPI3\u0026rsquo;s 5V is not enough to use servos long term. For initial testing they will work. But what you will find is the servos will glitch if connected to the RPI3\u0026rsquo;s header. The RPI3 causes the glitches. So eventually you need to find an alternative way to run the servos. There are two options I had on hand: a Maestro Mirco and PCA9685.\nI included some basic code to just make the servo work. I also added the actual code I used to control the arms through the RPI3.\nRead here on the Flask UI setup.\nFunction for Angle to Duty Cycle The difficult part with controlling the servo with a RPI3 is the value you use to move the servo. The value is given as a duty cycle. I looked around how to convert an angle to duty cycle. I finally found one that worked with my servos. I am using Tower Pro MG995. This function should work for must people, but you can change it if needed.\n1 2 3 4 5 6 7 8 9 10 @staticmethod def calc_duty_cycle_from_angle(angle): \u0026#34;\u0026#34;\u0026#34; Calculate the duty cycle based off the angle given. Then move the servo based off this angle. :param angle: :return: Duty cycle for servo based off angle. \u0026#34;\u0026#34;\u0026#34; #return ((angle / 180.0) + 1.0) * 5.0 return angle / 18.0 + 3.0 Schematic Connect the servos to the RPI3 directly.\nServo Color Code 1 2 3 Brown = GND Red = Power Orange = Signal Pinout 1 2 3 Orange -\u0026gt; Pin 7 (RPI3 GPIO 4) Red -\u0026gt; Pin 2 (RPI3 5V) Brown -\u0026gt; Pin 6 (RPI3 GND) RPI3 Servo R2D2 Arms Video RPI3 Running the Servos Code https://github.com/artoo-ai/R2D2/blob/master/controls/rpi3_servo_control.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 import RPi.GPIO as GPIO import time import sys class Rpi3ServoControl: \u0026#34;\u0026#34;\u0026#34; Use the RPI3 to control the servos. \u0026#34;\u0026#34;\u0026#34; def __init__(self, servo_pin, init_angle=0.0): self.servo_pin = servo_pin self.gpio_pin = None self.last_angle = 0.0 self.setup_pin() # Setup GPIO pin self.set_angle(init_angle) def setup_pin(self): \u0026#34;\u0026#34;\u0026#34; Setup the GPIO pin. Use the GPIO pin given in the constructor. :return: \u0026#34;\u0026#34;\u0026#34; GPIO.setmode(GPIO.BCM) # Setup GPIO pin to BCM GPIO.setup(self.servo_pin, GPIO.OUT) # Set GPIO pin to output self.gpio_pin = GPIO.PWM(self.servo_pin, 50) # GPIO PWM with 50Hz self.gpio_pin.start(2.5) # Initialization def shutdown(self): \u0026#34;\u0026#34;\u0026#34; Shutdown the object. This will properly shutdown everything. :return: \u0026#34;\u0026#34;\u0026#34; self.gpio_pin.stop() GPIO.cleanup() def center(self): \u0026#34;\u0026#34;\u0026#34; Center the servo. :return: \u0026#34;\u0026#34;\u0026#34; self.set_angle(0.0) # CENTER (7.5) def set_angle(self, angle): \u0026#34;\u0026#34;\u0026#34; Set the servo to the given angle. :param angle: Angle to move the servo :return: \u0026#34;\u0026#34;\u0026#34; if angle \u0026gt; 180: angle = 180 if angle \u0026lt; 0: angle = 0 # Cacluate the duty cycle to move to that angle dc = Rpi3ServoControl.calc_duty_cycle_from_angle(angle) print(\u0026#34;Pin: \u0026#34; + str(self.servo_pin) + \u0026#34; Angle: \u0026#34; + str(angle) + \u0026#34; DC: \u0026#34; + str(dc)) # Move the servo self.gpio_pin.ChangeDutyCycle(dc) time.sleep(0.1) # Record the last angle self.last_angle = angle @staticmethod def calc_duty_cycle_from_angle(angle): \u0026#34;\u0026#34;\u0026#34; Calculate the duty cycle based off the angle given. Then move the servo based off this angle. :param angle: :return: Duty cycle for servo based off angle. \u0026#34;\u0026#34;\u0026#34; #return ((angle / 180.0) + 1.0) * 5.0 return angle / 18.0 + 3.0 if __name__ == \u0026#39;__main__\u0026#39;: if len(sys.argv) \u0026gt; 1: print(\u0026#34;Using Servo Pin \u0026#34; + sys.argv[1]) rpi3_servo = Rpi3ServoControl(int(sys.argv[1])) else: print(\u0026#34;Using Servo Pin 4\u0026#34;) rpi3_servo = Rpi3ServoControl(4) if len(sys.argv) \u0026gt; 2: angle_list = sys.argv[2:] print(\u0026#34;Angles to try: \u0026#34; + str(sys.argv[2:])) for idx in range(len(angle_list)): rpi3_servo.set_angle(float(angle_list[idx])) time.sleep(0.5) rpi3_servo.shutdown() Basic Code In this example, I connected the servo signal pin to RPI3 GPIO pin 4. This will then open and close the servo.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import RPi.GPIO as GPIO import time servoPIN = 4 GPIO.setmode(GPIO.BCM) GPIO.setup(servoPIN, GPIO.OUT) p = GPIO.PWM(servoPIN, 50) # GPIO 17 for PWM with 50Hz p.start(2.5) # Initialization try: while True: p.ChangeDutyCycle(5) time.sleep(0.5) p.ChangeDutyCycle(7.5) # CENTER time.sleep(0.5) p.ChangeDutyCycle(10) time.sleep(0.5) p.ChangeDutyCycle(12.5) # 180 degrees time.sleep(0.5) p.ChangeDutyCycle(10) time.sleep(0.5) p.ChangeDutyCycle(7.5) # CENTER time.sleep(0.5) p.ChangeDutyCycle(5) time.sleep(0.5) p.ChangeDutyCycle(2.5) # 0 degrees time.sleep(0.5) except KeyboardInterrupt: p.stop() GPIO.cleanup() Parts List The R2D2 arm holder can be found at http://astromech.com/\n","date":"2019-06-13T12:29:40+06:00","image":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3/sch_hu66c7c2e3d76cecc690a95cac304a8b2d_96517_120x120_fill_box_smart1_3.png","permalink":"https://www.artoo.ai/p/r2d2-arm-connected-to-rpi3/","title":"R2D2 Arm Connected to RPI3"},{"content":"ROS Actions Similar to an ROS Service except you can do other things while the action is running. Actions are asynchronous.\nAction Servers and Action Clients Action Server contains the functionality\nAction Client calls the Action Server to perform a functionality.\nCommands 1 rostopic list # Look for /\u0026lt;action_server_name\u0026gt;/\u0026lt;unique_msg\u0026gt; Action Message Message that defines an action. It contains 3 parts: Goal, Result, Feedback.\nGoal is the arguments for the action.\nResult is the result when the action is complete.\nFeedback is feedback as the action is in progress\n1 2 3 4 5 6 7 8 # Goal int32 nseconds --- # Result sensor_msgs/CompressedImage[] allPictures --- # Feedback sensor_msgs/CompressedImage lastImage Python ROS Action Client 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import rospy import time import actionlib from ardrone_as.msg import ArdroneAction, ArdroneGoal, ArdroneResult, ArdroneFeedback nImage = 1 # Feedback callback def feedback_callback(feedback): global nImage print(\u0026#39;[Feedback] image n.%d received\u0026#39;%nImage) nImage += 1 # Init the action client node rospy.init_node(\u0026#39;drone_action_client\u0026#39;) # Create connection to the action server client = actionlib.SimpleActionClient(\u0026#39;/ardrone_action_server\u0026#39;, ArdroneAction) # waits until the action server is up and running client.wait_for_server() # create a goal to send to the action server goal = ArdroneGoal() goal.nseconds = 10 # Send the goal to the action server, specifying which feedback function # to call when feeback received client.send_goal(goal, feeback_cb=feedback_callback) client.wait_for_result() print(\u0026#39;[Result] State: %d\u0026#39;%(client.get_state())) Wait for Result Using ```wait_for_result()`` is like using a service.\nGet State Instead of waiting for result, you can call get_state() and continue to run while it is running.\n1 2 3 4 5 0 = PENDING 1 = ACTIVE 2 = DONE 3 = WARN 4 = ERROR Use a While loop and while the value returned is less than 2, you know it is still running.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ... PENDING = 0 ACTIVE = 1 DONE = 2 WARN = 3 ERROR = 4 state_result = client.get_state() rate = rospy.Rate(1) rospy.loginfo(\u0026#34;state_result \u0026#34; + str(state_result)) while state_result \u0026lt; DONE: rospy.loginfo(\u0026#34;Doing Stuff while waiting for the server to give a result...\u0026#34;) rate.sleep() state_result = client.get_state() rospy.loginfo(\u0026#34;state_result: \u0026#34; + str(state_result)) rospy.loginfo(\u0026#34;[Result] State: \u0026#34; + str(state_result)) if state_result == ERROR: rospy.logerr(\u0026#34;Something went wrong in the server side\u0026#34;) if state_result == WARN: rospy.logwarn(\u0026#34;There is a warning in the Server Side\u0026#34;) More Details ","date":"2019-01-04T12:29:40+06:00","permalink":"https://www.artoo.ai/p/ros-actions/","title":"ROS Actions"},{"content":"ROS Service A service is a node that must run and you must wait until it has completed.\nCommands 1 2 3 4 rosservice list rosservice info \u0026lt;service name\u0026gt; # Node, URI, Type and Args rossrv show \u0026lt;service name\u0026gt; # Args and return type rosservice call \u0026lt;service name\u0026gt; \u0026lt;args\u0026gt; # \u0026#34;{}\u0026#34; is empty arg Python Call ROS Service 1 2 3 4 5 6 7 8 9 10 11 import rospy from gazebo_msgs.srv import DeleteModel, DeleteModelRequest import sys rospy.init_node(\u0026#39;service_client\u0026#39;) rospy.wait_for_service(\u0026#39;/gazebo/delete_model\u0026#39;) # Wait for the service client to be running delete_model_service = rospy.ServiceProxy(\u0026#39;/gazebo/delete_model\u0026#39;, DeleteModel) # Create the connection to the service kk = DeleteRequest() kk.model_name = \u0026#34;bowl_1\u0026#34; # Create an Arg for the service result = delete_model_service(kk) print(result) Python Create an ROS Service 1 2 3 4 5 6 7 8 9 10 11 import rospy from std_srvs.srv import Empty, EmptyResponse def my_callback(request): print \u0026#34;My_callback has been called\u0026#34; return EmptyResponse() #return MyServiceResponse(len(request.words.split())) rospy.init_node(\u0026#39;service_server\u0026#39;) my_service = rospy.Service(\u0026#39;/my_service\u0026#39;, Empty, my_callback) rospy.spin() # maintain the service open Call Service 1 rosservice call /my_service \u0026#34;{}\u0026#34; Create a Catkin Service Project Create Project 1 2 3 4 5 6 roscd cd ../src/ catkin_create_pkg my_custom_srv_msg_pkg rospy roscd my_custom_srv_msg_pkg mkdir srv vim srv/MyCustomServiceMessage.srv Create Service File Service file containing the arguments and return type.\n1 2 3 4 float64 radius int32 repititions --- bool success Modify CMakeList.txt and Package.xml CMakeList.txt 1 2 3 4 find_package(catkin REQUIRED COMPONENTS std_msgs message_generation ) 1 2 3 4 add_service_files( FILES MyCustomServiceMessage.srv ) 1 2 3 4 catkin_package( CATKIN_DEPENDS rospy ) Uncomment area\n1 2 3 4 generate_messages( DEPENDENCIES std_msgs ) Package.xml Add Lines\n1 2 \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;run_depend\u0026gt;message_runtime\u0026lt;/run_depend\u0026gt; Build Project 1 2 3 roscd;cd .. catkin_make source devel/setup.bash Test Project 1 2 rossrv list | grep MyCustomServiceMessage rossrv show my_custom_srv_msg_pkg/MyCustomServiceMessage More Details ","date":"2019-01-04T12:29:40+06:00","permalink":"https://www.artoo.ai/p/ros-service/","title":"ROS Service"},{"content":"Notes about an ROS Topic. This will describe a basic publisher and subscriber topic. Where to find the list of topics and the list of possible messages for a topic. How to install a new message for a topic.\n1 2 3 4 5 6 rostopic list rosmsg list rostopic type \u0026lt;topic\u0026gt; rostopic echo \u0026lt;topic\u0026gt; rostopic info \u0026lt;topic\u0026gt; rostopic hz \u0026lt;topic\u0026gt; Publisher Publish messages into a topic\nPublish in Code 1 2 3 4 5 6 7 8 9 10 11 12 13 import rospy from geometry_msgs.msg import Twist rospy.init_node(\u0026#39;robot_mover\u0026#39;) # Create Publisher pub = rospy.Publisher(\u0026#39;/cmd_move\u0026#39;, Twist, queue_size=1) # Set the data type for the publisher rate = rospy.Rate(2) # 2hz move = Twist() # Create a Twist object move.linear.x = 0.5 # Move forward on x 0.5 move.angular.z = 0.5 # Move at an anglular rate of 0.5 while not rospy.is_shutdown(): pub.publish(move) # Publish the move rate.sleep() # Maintain the refresh rate Publish on Commandline Manually publish in command line\n1 rostopic pub /cmd_move geometry_msgs/Twist \u0026#34;linear: x: 0.5 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.5\u0026#34; rostopic pub \u0026lt;topic_name\u0026gt; \u0026lt;message_type\u0026gt; \u0026lt;value\u0026gt;\nYou can use the \u0026lsquo;double tab\u0026rsquo; to autofil the value.\nSubscriber Read messages from a topic\nSubscribe in Code 1 2 3 4 5 6 7 8 9 import rospy from std_msgs.msg import Int32 def callback(msg) print(msg.data) rospy.init_node(\u0026#39;topic_subscriber\u0026#39;) sub = rospy.Subscriber(\u0026#39;/counter\u0026#39;, Int32, callback) rospy.spin() Determine the message type of the topic 1 rostopic info /counter This will return back the data type, publishers and subscribers for the given topic.\nCreate a Custom Data Type Create a directory in the package\n1 2 roscd my_new_package mkdir msg Create the Data type Create a file within the new directory for the new data type Call it Vector.msg. Add the following in to the file\n1 2 float32 magnitude float32 direction Edit CMakeLists.txt Edit CMakeLists.txt in the package to find the new data type. Look for find_package(catkin REQUIRED COMPONENTS \u0026hellip;)\n1 2 3 4 5 find_package(catkin REQUIRED COMPONENTS rospy std_msgs message_generation ) Again within CMakeLists.txt search for catkin_package(\u0026hellip;) and uncomment the following line and append it if it contains other things passed CAKTIN_DEPENDS.\n1 2 3 catkin_package( CATKIN_DEPENDS message_runtime ) Again within CMakeLists.txt search for add_message_files(\u0026hellip;) and uncomment it and add the new messages.\n1 2 3 4 add_message_files( FILES Vector.msg ) Again within CMakeLists.txt search for generate_messages(\u0026hellip;) and uncomment it.\n1 2 3 4 generate_messages( DEPENDENCIES std_msgs ) Save the CMakeLists.txt file.\nEdit package.xml Edit package.xml in the package to find our new data type. Find build_depend\u0026hellip;\n1 2 \u0026lt;build_depend\u0026gt;message_generation\u0026lt;/build_depend\u0026gt; \u0026lt;run_depend\u0026gt;message_runtime\u0026lt;/run_depend\u0026gt; Compile Code Go to your catkin workspace and run catkin_make\n1 2 cd catkin_ws catkin_make Verify Data Type Exist 1 rosmsg show Vector Stop Topic 1 rosnode kill /cmd_move All the details for this can be found in this video. ","date":"2019-01-01T12:29:40+06:00","permalink":"https://www.artoo.ai/p/ros-topic/","title":"ROS Topic"},{"content":"Modify the kernal for uvcvideo 1 2 git clone https://github.com/jetsonhacks/installLibrealsenseTX1.git cd installLibrealsenseTX1 Modify the address to use the Euclid libRealsense Modify the address to use the Euclid version of libRealSense https://github.com/IntelEuclid/librealsense\n1 ./installLibrealsense Make sure the folder $HOME/librealsense does not exist. If it does, delete the file.\n1 sudo apt install motion Get Motion Installed 1 2 wget https://github.com/Motion-Project/motion/releases/download/release-4.2/xenial_motion_4.2-1_amd64.deb sudo apt-get install xenial_motion_4.2-1_amd64.deb Install ROS 1 2 3 git clone https://github.com/jetsonhacks/installROSTX1.git cd installROSTX1 ./installROSTX1 -p ros-kinetic-desktop-full 1 ./setupWorkspace.sh catkinWS https://www.jetsonhacks.com/2016/10/12/robot-operating-system-ros-on-nvidia-jetson-tx1/\nInstall Reaslsense with ROS 1 2 git clone https://github.com/jetsonhacks/installRealSenseROSTX1 cd installRealSenseROSTX1 Modify the address to use the Euclid version of libRealSense https://github.com/IntelEuclid/librealsense\n1 ./installRealSenseROSTX1 catkinWS https://www.jetsonhacks.com/2016/10/26/intel-realsense-package-for-ros-on-nvidia-jetson-tx1/\n1 2 cd /usr/lib/aarch64-linux-gnu/ sudo ln -sf tegra/libGL.so libGL.so This will run the script file to install all the missing files and all the files needed for LibRealsense to run on the system.\nRun the examples 1 cd $HOME/librealsense/build/example Run any of the examples. Make sure the Euclid is plugged in the USB port and makes sure it is turned on.\nWifi IP 10.42.0.1\nEuclid not recongized by USB Port 1 sudo usermod -a -G dialout $USER You will have to logout and then log back in before the group change is recognized.\nhttps://github.com/IntelRealSense/librealsense/issues/195\nUbuntu Menu Bars not seen after reboot 1 2 rm -rf ~/.cache/compizconfig-1/* setsid unity https://askubuntu.com/questions/761035/ubuntu-16-04-no-menu-bar-or-launcher-help\nSetup Realsense for ROS 1 sudo apt-get install ros-kinetic-realsense-camera I get an error message when install the ros kinetic realsense camera from APT:\n1 ERROR: Module uvcvideo not found. Handle the error https://github.com/IntelRealSense/librealsense/blob/master/doc/installation.md#video4linux-backend-preparation\nhttps://www.jetsonhacks.com/2016/10/06/intel-realsense-camera-installation-nvidia-jetson-tx1/\nhttps://www.jetsonhacks.com/2017/08/14/intel-realsense-camera-librealsense-nvidia-jetson-tx-dev-kits/\n","date":"2018-12-05T12:29:40+06:00","permalink":"https://www.artoo.ai/p/ros-intel-euclid-install-on-nvidia-jeston-tx1/","title":"ROS Intel Euclid Install on Nvidia Jeston TX1"},{"content":"Descriptions Descriptions I am testing here the number of epochs to use. I am monitoring the Loss to make sure it drops and if it plateaus. If it plateaus, where does it begin to plateau. I am also using a very small dropout and using RMSPROP. The learning rate is left default.\nGood results will have the car remaining on the track consitently. It may drive off, in certain areas if the training is not good, but it should for the most part stay within the lines. The video shows the result of the parameters.\nParameters 50 Epochs Typically only need 23 for early stop to end RMSPROP Could also use Adam 10% Dropout Typically you see 50% 1e-4 Learning Rate A default value to start with Results Pretty good results. Went off the track in certain areas. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 BATCH_SIZE = 128 TRAIN_TEST_SPLIT = 0.8 # Keras settings TRAINING_MODEL = MODEL_TYPE_CATEGORICAL # Type of Neural Network model IS_TENSORBOARD = True # Create Tensorboard data IS_PLOT_RESULTS = True # Create matplotlib plots IS_EARLY_STOP = False # If no improve, stop training early EARLY_STOP_COUNT = 5 # Number of no changes before stopping LEARNING_RATE = 1.0e-4 # Learn rate. Decrease to fix bias EPOCHS = 50 # Number of epochs to run. DROPOUT_1 = 0.1 # First Dropout percentage DROPOUT_2 = 0.1 # Second Dropout percentage OPTIMIZER = OPTIMIZER_TYPE_RMSPROP # Type of Optimizer to use. LOSS_WEIGHT_ANGLE = 0.9 # Loss weight for Angles LOSS_WEIGHT_THROTTLE = 0.001 # Loss Weight for Throttle Test 4 Loss Plot Test 4 Angle Out Loss Plot Test 4 Angle Out Accuracy Plot Test 4 Throttle Out Loss Plot Test 4 Throttle Out Accuracy Plot ","date":"2017-11-02T00:00:00Z","permalink":"https://www.artoo.ai/p/donkeycar-test-4/","title":"Donkeycar Test 4"}]